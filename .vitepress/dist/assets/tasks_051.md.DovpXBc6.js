import{_ as t,c as o,o as a,a2 as s}from"./chunks/framework.C94oF1kp.js";const e="/assets/17.B4_H1tL0.png",u=JSON.parse('{"title":"Алгоритм Дейкстры.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/051.md","filePath":"tasks/051.md"}'),r={name:"tasks/051.md"},n=s('<h1 id="алгоритм-деикстры" tabindex="-1">Алгоритм Дейкстры. <a class="header-anchor" href="#алгоритм-деикстры" aria-label="Permalink to &quot;Алгоритм Дейкстры.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Алгоритм Дейкстры</strong> — это алгоритм поиска кратчайших путей от одной из вершин (называемой источником) ко всем остальным вершинам во взвешенном ориентированном графе с неотрицательными весами ребер.</p><ol><li><strong>Инициализация:</strong> Установите начальную вершину (источник) и расстояние до всех остальных вершин как &quot;бесконечность&quot;, за исключением начальной вершины, для которой расстояние устанавливается как 0. Текущее расстояние от источника до самого себя также устанавливается как 0.</li><li><strong>Выбор ближайшей вершины:</strong> Начиная с источника, на каждом шаге выбирается вершина с наименьшим известным расстоянием до нее (если перебор, то O(n^2)). Это может быть сделано с использованием очереди с приоритетом, где вершины отсортированы по их текущему расстоянию (двоичная куча O(n log n)).</li><li><strong>Релаксация ребер:</strong> Для каждой выбранной вершины пересчитывается расстояние до всех ее соседних вершин. Если новое расстояние меньше текущего, оно обновляется.</li><li><strong>Повторение:</strong> Шаги 2 и 3 повторяются, пока все вершины не будут посещены или пока не будут найдены кратчайшие пути до всех вершин.</li><li><strong>Завершение:</strong> По завершении работы алгоритма, расстояния до всех вершин от источника будут определены.</li></ol><p>Этот алгоритм работает только для графов без отрицательных ребер, так как он не способен обрабатывать циклы отрицательного веса, которые могут привести к бесконечному увеличению длины пути.</p><blockquote><p>Также есть вариация Дейкстры, где вместо выбора минимальной вершины, постепенно рассматриваются все соседи каждой вершины и пересчитываются расстояния до них. Стартуем из источника, рассматриваем соседей, обновляем их расстояния, закидываем в очередь их соседей, продолжаем пока очередь не пуста.</p></blockquote><p><img src="'+e+'" alt=""></p>',7),i=[n];function l(_,c,p,d,g,h){return a(),o("div",null,i)}const f=t(r,[["render",l]]);export{u as __pageData,f as default};
