import{_ as t,c as o,o as s,a2 as r}from"./chunks/framework.C94oF1kp.js";const n="/assets/25.BPIpA2zQ.png",m=JSON.parse('{"title":"Динамическое программирование. Задача о количестве маршрутов. Принцип Беллмана.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/039.md","filePath":"tasks/039.md"}'),a={name:"tasks/039.md"},e=r('<h1 id="динамическое-программирование-задача-о-количестве-маршрутов-принцип-беллмана" tabindex="-1">Динамическое программирование. Задача о количестве маршрутов. Принцип Беллмана. <a class="header-anchor" href="#динамическое-программирование-задача-о-количестве-маршрутов-принцип-беллмана" aria-label="Permalink to &quot;Динамическое программирование. Задача о количестве маршрутов. Принцип Беллмана.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Динамическое программирование</strong> - это метод решения оптимизационных задач, в которых решение можно разбить на более мелкие подзадачи, которые, в свою очередь, также можно разбить на еще более мелкие подзадачи. При этом решение каждой подзадачи используется для решения более крупных подзадач, пока не будет найдено решение всей задачи в целом.</p><blockquote><p><strong>Динамическое</strong> <strong>программирование</strong> похоже на метод <strong>«разделяй и властвуй»</strong> оба из которых решают исходную проблему путем решения подзадач. <strong>Разница</strong> в том, что алгоритм «<strong>разделяй</strong> <strong>и</strong> <strong>властвуй</strong>» будет выполнять много ненужной работы при решении подзадач, он будет многократно решать эти общие подзадачи; в то время как алгоритм <strong>динамического</strong> <strong>программирования</strong> решает каждую подзадачу только один раз, и сохраняет свое решение.</p></blockquote><p>В рекурсии например результаты подзадач используется при формировании ответа, но никак не помогают при решении подзадач.</p><p>Что эффективнее?</p><ul><li>рекурсия с ответом: return fibo(n-1) + fibo(n-2) без мемоизации</li><li>последовательное вычисление каждого числа фибоначчи, но ровно 1 раз.</li></ul><blockquote><p><strong>Принцип оптимальности Беллмана:</strong> алгоритм считается оптимальным, если на любом его шаге для получения оптимального решения, используется результат его предыдущих решений.</p></blockquote><h2 id="задача" tabindex="-1">Задача <a class="header-anchor" href="#задача" aria-label="Permalink to &quot;Задача&quot;">​</a></h2><p><strong>Задача о количестве маршрутов:</strong> имеются несколько городов и между некоторыми из них проведены односторонние дороги так, что выехав из города, вернуться по той же дороге невозможно. Требуется найти кол-во маршрутов из одного пункта в другой.</p><p><strong>Идея:</strong> чтобы подсчитать кол-во путей до пункта, необходимо знать сколькими способами мы можем попасть в пункты ведущие в этот и т.д.</p><p><strong>Ход алгоритма:</strong></p><ol><li>устанавливаем значение стартовой вершины 1</li><li>проходимся по графу, например в матрице смежности и устанавливаем значение вершины как сумма значений вершин, которые ведут в неё</li></ol><p><img src="'+n+'" alt=""></p>',14),l=[e];function i(p,c,g,_,d,h){return s(),o("div",null,l)}const f=t(a,[["render",i]]);export{m as __pageData,f as default};
