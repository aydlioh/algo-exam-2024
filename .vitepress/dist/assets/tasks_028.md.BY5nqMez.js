import{_ as t,c as a,o,a2 as r}from"./chunks/framework.C94oF1kp.js";const m=JSON.parse('{"title":"Внешний поиск. B-деревья.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/028.md","filePath":"tasks/028.md"}'),e={name:"tasks/028.md"},s=r('<h1 id="внешнии-поиск-b-деревья" tabindex="-1">Внешний поиск. B-деревья. <a class="header-anchor" href="#внешнии-поиск-b-деревья" aria-label="Permalink to &quot;Внешний поиск. B-деревья.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>B-деревья</strong> — это самобалансирующаяся структура данных, которая используется для эффективного управления большими объемами данных и поддержания их в отсортированном виде. Они особенно полезны в базах данных и файловых системах, где требуется чтение и запись больших блоков данных.</p><h2 id="своиства" tabindex="-1">Свойства <a class="header-anchor" href="#своиства" aria-label="Permalink to &quot;Свойства&quot;">​</a></h2><ul><li><strong>Сбалансированная структура дерева:</strong> Все листовые узлы находятся на одном уровне, что обеспечивает сбалансированную высоту дерева и способствует эффективному выполнению операций.</li><li><strong>Порядок и вместимость узлов:</strong> Порядок B-дерева, обозначаемый как &quot;m&quot;, указывает на максимальное количество потомков, которое может иметь узел. Узел в B-дереве порядка &quot;m&quot; может иметь до &quot;m-1&quot; ключей и &quot;m&quot; потомков.</li><li><strong>Минимальное количество потомков:</strong> Каждый узел, кроме корня, должен иметь как минимум ⌈m/2⌉ потомков</li><li><strong>Корневой узел:</strong> Корневой узел должен содержать как минимум два потомка, если он не является листом.</li><li><strong>Листовые узлы:</strong> Все листовые узлы находятся на одном уровне.</li></ul><h2 id="операции" tabindex="-1">Операции <a class="header-anchor" href="#операции" aria-label="Permalink to &quot;Операции&quot;">​</a></h2><ul><li><strong>Поиск:</strong> Поиск ключа в B-дереве начинается с корня и продолжается через внутренние узлы, пока не будет найден нужный ключ или достигнут листовой узел. Время поиска в среднем составляет O(log n).</li><li><strong>Вставка:</strong> Новые ключи добавляются в соответствующее место в существующем узле. Если узел переполняется (превышает максимальное количество ключей), он делится на два узла, и средний ключ перемещается вверх к родительскому узлу и начинает указывать на два новых узла. Время вставки также O(log n).</li><li><strong>Удаление:</strong> Удаление ключа может быть более сложным, так как необходимо поддерживать свойства B-дерева. Если удаление ключа приводит к тому, что узел становится слишком малым (меньше минимального количества ключей), могут потребоваться слияние с соседним узлом или перемещение ключей из родительского узла. Время удаления — O(log n).</li></ul>',7),n=[s];function l(i,_,c,h,d,u){return o(),a("div",null,n)}const q=t(e,[["render",l]]);export{m as __pageData,q as default};
