import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.C94oF1kp.js";const o=JSON.parse('{"title":"Жадные алгоритмы. Задача о резервных копиях.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/035.md","filePath":"tasks/035.md"}'),h={name:"tasks/035.md"},t=n(`<h1 id="жадные-алгоритмы-задача-о-резервных-копиях" tabindex="-1">Жадные алгоритмы. Задача о резервных копиях. <a class="header-anchor" href="#жадные-алгоритмы-задача-о-резервных-копиях" aria-label="Permalink to &quot;Жадные алгоритмы. Задача о резервных копиях.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Задача о резервных копиях:</strong> имеется система, состоящая из N хранилищ, различной ёмкости. В i-ом хранилище можно разместить Ai блоков информации. Хранение блока считается <code>надежным</code>, если в хранилище <code>есть 2 его копии</code>. Требуется определить <code>наибольшее кол-во надежных блоков</code>, которое можно разместить во всех хранилищах   Для объяснения решение этой задачи, рассматривают эквивалентную задачу про <strong>камушки</strong>:</p><p>Есть N кучек камней, каждым ходом можно забрать по одинаковому кол-ву камней из двух кучек. Найти такой порядок ходов, при котором в игре останется минимальное кол-во камней(либо во всех по 0, либо только в 1, и то минимум).</p><h2 id="стратегия" tabindex="-1">Стратегия <a class="header-anchor" href="#стратегия" aria-label="Permalink to &quot;Стратегия&quot;">​</a></h2><ul><li>Выбираем наибольшую и наименьшую по кол-ву камней кучи и берём из них по 1 камню.</li><li>Продолжаем выполнять действие пока есть хотя бы 2 кучи, в которых есть камни.</li></ul><p><img src="https://lh7-us.googleusercontent.com/docsz/AD_4nXf-B6iE-nmJIq48Wh2UXz8kj3ji6FiOY2Dyha18CbEGYaeDx9OsP2P0BbuIyRUPcDgaclWJoKxzyfJ6-_TeqjIrsZj4uvES2tUYv3E2Woneelq_Qqho1fxTZTsEPw9_ikagyrbKUQNfhnm41WiTOFUBYKgk?key=9gziK4gT-jwK64_BpOeehQ" alt=""></p><p>Таким образом, кол-во ходов и будет ответом к задаче, потому что показывает максимальное кол-во пар, которое можно разместить в хранилище.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> max_reliable_blocks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storages):  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Сортировка хранилищ по убыванию ёмкости  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    storages.sort(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=lambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: x[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;capacity&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reverse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    total_blocks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> storage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> storages:  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        capacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> storage[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;capacity&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        blocks_needed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(capacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Рассчитываем, сколько блоков можно разместить  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        total_blocks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> blocks_needed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Добавляем блоки, умноженные на 2 (для двух копий)  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        capacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> blocks_needed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Уменьшаем ёмкость хранилища  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> capacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            break</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Если ёмкости осталось мало, прерываем цикл  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_blocks</span></span></code></pre></div><p>Вся СУТЬ задачи в том, что минимальное возможное действие - оставить файл размером 1 в двух хранилищах. Ограничение в том, что места обязательно должны быть разные. Если у нас три хранилища с размерами 3 4 5 и мы оставим по 3 копии в (1) и (2) хранилище, то получим 0 1 5. Затем остаётся единственный вариант - оставить 1 копию в (2) и (3) хранилище с результатом 0 0 4. У нас ещё целых четыре места, но копии нельзя разместить в одном хранилище. В сумме мы разместили всего 4 копии, хотя с наилучшей стратегией можно разместить аж 6 копий</p>`,10),k=[t];function l(p,e,r,E,d,g){return a(),i("div",null,k)}const y=s(h,[["render",l]]);export{o as __pageData,y as default};
