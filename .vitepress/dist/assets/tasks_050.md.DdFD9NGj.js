import{_ as t,c as a,o as s,a2 as o}from"./chunks/framework.C94oF1kp.js";const e="/assets/16.pe5Tup6K.png",u=JSON.parse('{"title":"Алгоритма Краскала.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/050.md","filePath":"tasks/050.md"}'),r={name:"tasks/050.md"},n=o('<h1 id="алгоритма-краскала" tabindex="-1">Алгоритма Краскала. <a class="header-anchor" href="#алгоритма-краскала" aria-label="Permalink to &quot;Алгоритма Краскала.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Алгоритм Краскала</strong> — это алгоритм для нахождения минимального остовного дерева (MST) во взвешенном связном графе. В отличие от алгоритма Прима, который оперирует с вершинами, алгоритм Краскала оперирует с ребрами графа. Он начинает с самого маленького ребра и постепенно добавляет ребра с наименьшими весами, при условии что они не образуют циклы, пока не будет построено дерево, содержащее все вершины исходного графа.</p><ol><li><strong>Инициализация:</strong> Создайте набор всех ребер графа.</li><li><strong>Сортировка ребер:</strong> Отсортируйте все ребра графа в порядке возрастания весов.</li><li><strong>Итерация по ребрам:</strong> Переберите отсортированные ребра.</li></ol><p>Для каждой из вершин создаётся её единичное подмножество. При рассмотрении ребра, берём номера вершин (соответственно их подмножеств), выбираем номер минимального подмножества из этих 2, заносим вторую.</p><p>Аналогичную операцию проводим, если ребро соединяет не просто 2 единичных подмножества, а уже более крупные подмножества, состоящие из нескольких вершин. (сливаем, номер берем минимальный)</p><p>Ребро образует цикл, если соединяет 2 вершины, которые уже принадлежат одному подмножеству, такие ребра пропускаем.</p><ul><li><strong>Повторение:</strong> алгоритм повторяется пока все вершины не будут принадлежать одному подмножеству</li><li><strong>Завершение:</strong> Когда MST содержит все вершины из исходного графа, алгоритм завершается.</li></ul><p><img src="'+e+'" alt=""></p>',9),i=[n];function l(_,c,p,d,h,g){return s(),a("div",null,i)}const f=t(r,[["render",l]]);export{u as __pageData,f as default};
