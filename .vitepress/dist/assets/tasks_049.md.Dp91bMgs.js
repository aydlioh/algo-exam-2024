import{_ as t,c as o,o as s,a2 as a}from"./chunks/framework.C94oF1kp.js";const e="/assets/14.ZKqyDPUU.png",T=JSON.parse('{"title":"Алгоритм Прима.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/049.md","filePath":"tasks/049.md"}'),n={name:"tasks/049.md"},r=a('<h1 id="алгоритм-прима" tabindex="-1">Алгоритм Прима. <a class="header-anchor" href="#алгоритм-прима" aria-label="Permalink to &quot;Алгоритм Прима.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Алгоритм Прима</strong> — это алгоритм для нахождения минимального остовного дерева (MST) во взвешенном связном графе. Он начинает с одной случайно выбранной вершины и постепенно расширяет остовное дерево, добавляя к нему ребра с наименьшим весом, пока не будет построено дерево, содержащее все вершины исходного графа.</p><ol><li><strong>Инициализация:</strong> Выберите любую начальную вершину из графа и поместите ее в MST.</li><li><strong>Обновление набора кандидатов ребер:</strong> Из всех ребер, инцидентных <code>вершинам</code> в MST, выберите ребро с наименьшим весом, которое присоединяет вершину MST к вершине вне MST. Добавьте это ребро в MST.</li><li><strong>Обновление множества кандидатов вершин:</strong> Поместите новую вершину (вершину, соединенную выбранным ребром) в MST.</li><li><strong>Повторение шагов 2-3:</strong> Повторяйте шаги 2 и 3 до тех пор, пока MST не содержит все вершины из исходного графа.</li><li><strong>Завершение:</strong> Когда MST содержит все вершины из исходного графа, алгоритм завершается.</li></ol><p><strong>Сложность O(n^2), n- кол-во ребер, т.к. мы на каждом шаге перебираем в худшем случае все рёбра и выбираем минимальное.</strong></p><blockquote><p>m - вершины, n - ребра Эффективный алгоритм, работающий за O(m log n), предлагает хранить все доступные ребра, которые соединяют остовные вершины с ещё не остовными вершинами, в очереди с приоритетом. Таким образом при добавлении новой вершины мы добавляем ее ребра в очередь, перезаписываем расстояние (если есть 2 ребра ведущие в 1 вершину, берем минимальное), сортируем, находя минимальное ребро при изменениях за log n.</p></blockquote><p><img src="'+e+'" alt=""></p>',7),l=[r];function i(_,c,d,p,g,h){return s(),o("div",null,l)}const S=t(n,[["render",i]]);export{T as __pageData,S as default};
