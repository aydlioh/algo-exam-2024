import{_ as l,c as i,o,a2 as a}from"./chunks/framework.C94oF1kp.js";const g=JSON.parse('{"title":"Префиксное дерево. Задача о покрытии строки.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/038.md","filePath":"tasks/038.md"}'),t={name:"tasks/038.md"},e=a('<h1 id="префиксное-дерево-задача-о-покрытии-строки" tabindex="-1">Префиксное дерево. Задача о покрытии строки. <a class="header-anchor" href="#префиксное-дерево-задача-о-покрытии-строки" aria-label="Permalink to &quot;Префиксное дерево. Задача о покрытии строки.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Префиксное дерево (или бор)</strong> - это структура данных, используемая для хранения набора строк, которая позволяет эффективно выполнять операции поиска, вставки и удаления строк, а также выполнять операции нахождения всех строк, являющихся префиксами данной строки.</p><p><code>Префиксное дерево</code> состоит из узлов, каждый из которых содержит ссылки на дочерние узлы, представляющие символы алфавита. Путь от корня до узла представляет собой строку, образованную символами, представленными на этом пути.</p><p><strong>Префиксное дерево</strong> Дерево, которое мы строили в предыдущей задаче (кодирование по Хаффману), уже было префиксным, но <code>оно позволяло кодировать только последовательностями из нулей и единиц</code>, так как каждый узел имел не более двух потомков. Идея о том, что каждая ветка однозначно определяет код, позволяет иногда уменьшить количество данных, требуемых для представления. Не умаляя общности, положим, что из каждого узла всегда выходит ровно три ветви, A, B и C. Каждая из веток приходит либо в узел, либо в вершину, либо в никуда.</p><p>Алгоритм построения префиксного дерева оказывается достаточно простым.</p><ol><li>Создаём вершину дерева — узел с пустыми ветвями.</li><li>Для каждого слова исполняем: <ul><li>Устанавливаем указатель в вершину дерева.</li><li>Считываем очередную букву.</li><li>Если текущий узел не содержит нужной ветви, создаём эту ветвь и пустой узел на ней.</li><li>Переходим в нужную ветвь.</li><li>Если узел уже серый или не пустой, завершаем алгоритм с неудачей.</li><li>Если слово закончилось, то помечаем узел серым цветом.</li><li>Считываем очередную букву....</li></ul></li><li>Завершаем алгоритм с успехом.</li></ol><p><img src="https://ocw.cs.pub.ro/courses/_media/sd-ca/laboratoare/trie12.jpg?w=420&amp;h=380&amp;tok=4f05a6" alt=""></p><h2 id="задача" tabindex="-1">Задача <a class="header-anchor" href="#задача" aria-label="Permalink to &quot;Задача&quot;">​</a></h2><p><strong>Задача о покрытии строки:</strong> имеется набор слов, и ни одно из них не начинается с другого, то есть они образуют префиксный код. Имеется строка p - предложение. Требуется определить можно ли составить предложение из набора слов. <code>Цель</code> - найти оптимальное решение.</p><p><strong>Не оптимальный алгоритм</strong> Решение с использованием жадных алгоритмов:</p><ol><li>начинаем с первого символа строки</li><li>ищем слова которые начинаются с этого символа</li><li>если таких нет, то ответ “нет”, иначе сдвигаем указатель строки и дальше сравниваем символы с найденными подстроками</li><li>последовательно доходим до конца подстроки, возвращаемся к п.2 сложность O(n*m), где n-длина предложения, m-сумма длин всех слов.</li></ol><p><strong>Оптимальный алгоритм</strong> заключается в построении префиксного дерева.</p><ol><li>Начинаем от корня, берём все уникальные символы с которых начинаются наши слова и соединяем с корнем(построили 1 уровень дерева).</li><li>Последовательно проходимся по словам и дереву и добавляем необходимые вершины.</li><li>Если доходим до конца слова, помечаем вершину серой.</li></ol><p><img src="https://lh7-us.googleusercontent.com/docsz/AD_4nXfWk5CckzsvWBgVTXfTjGiTRkfgual4vVsVNWHDMuzYuyyLwlbhAWqF2iYaQ2UZElIs5NU2cfH9ksxJedDn0SfG7g4jR7qc1edQs1jZfQHzyDv87MKpE-2oXBkP3Ommswm6_2ilYmIxjDFEugVT8W9MKyU?key=9gziK4gT-jwK64_BpOeehQ" alt=""></p><p>Поиск по такому дереву стал элементарным:</p><ol><li>Считываем первый символ, идем в соответствующую вершину из корня, если такой нет, то возвращаем “нет”</li><li>Повторяем п.1, пока не доходим до серой вершины (указатель на конец слова)</li><li>Вновь поднимаемся в корень и повторяем п.1 и п.2</li></ol><p>Общая сложность этого алгоритма O(n + m)</p>',18),s=[e];function r(n,c,p,d,_,h){return o(),i("div",null,s)}const u=l(t,[["render",r]]);export{g as __pageData,u as default};
