import{_ as e,c as t,o as a,a2 as o}from"./chunks/framework.C94oF1kp.js";const h=JSON.parse('{"title":"Нахождение k-порядковой статистики.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/011.md","filePath":"tasks/011.md"}'),c={name:"tasks/011.md"},i=o('<h1 id="нахождение-k-порядковои-статистики" tabindex="-1">Нахождение k-порядковой статистики. <a class="header-anchor" href="#нахождение-k-порядковои-статистики" aria-label="Permalink to &quot;Нахождение k-порядковой статистики.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Нахождение k-порядковой статистики</strong> - это задача, которая заключается в нахождении элемента, занимающего k-ю позицию в отсортированном массиве (изначально массив не отсортирован). Например, если k равно 3, то мы ищем третий элемент в отсортированном массиве.</p><p>Один из эффективных алгоритмов для нахождения k-порядковой статистики - это алгоритм <code>QuickSelect</code>, который основан на алгоритме <code>QuickSort</code>. Алгоритм &quot;QuickSelect&quot; работает следующим образом:</p><ol><li>Выбираем опорный элемент из массива(случайно).</li><li>Если длина массива 1, возвращаем ответ.</li><li>Разбиваем массив на два подмассива: элементы, меньшие опорного(левый), и элементы, большие или равные опорному(правый).</li><li>Если размер левого подмассива элементов, равен k-1, то опорный элемент является k-порядковой статистикой.</li><li>Если размер  левого подмассива элементов, больше k, то искомый элемент находится в этом подмассиве, рекурсивно применяем алгоритм QuickSelect([подмассив], k).</li><li>Иначе, искомый элемент находится в правом подмассиве. Рекурсивно применяем алгоритм QuickSelect([подмассив], k-n), где n- длина  левого подмассива.</li></ol><p>Алгоритм &quot;QuickSelect&quot; имеет среднюю сложность O(n), где n - размер массива, и является более эффективным, чем полная сортировка массива для нахождения k-порядковой статистики.</p><p>Однако, в худшем случае, когда опорный элемент выбирается неудачно, алгоритм &quot;QuickSelect&quot; может иметь сложность O(n^2). Для уменьшения вероятности худшего случая, можно использовать медиану из трех элементов в качестве опорного, либо использовать более сложные стратегии выбора опорного элемента.</p>',7),l=[i];function s(r,n,k,_,d,u){return a(),t("div",null,l)}const S=e(c,[["render",s]]);export{h as __pageData,S as default};
