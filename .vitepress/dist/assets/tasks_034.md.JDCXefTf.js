import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.C94oF1kp.js";const c=JSON.parse('{"title":"Жадные алгоритмы. Задача об интервалах.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/034.md","filePath":"tasks/034.md"}'),t={name:"tasks/034.md"},h=n(`<h1 id="жадные-алгоритмы-задача-об-интервалах" tabindex="-1">Жадные алгоритмы. Задача об интервалах. <a class="header-anchor" href="#жадные-алгоритмы-задача-об-интервалах" aria-label="Permalink to &quot;Жадные алгоритмы. Задача об интервалах.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Жадные алгоритмы</strong> — это класс алгоритмов, которые делают локально оптимальный выбор в надежде на то, что этот выбор приведет к глобально оптимальному решению задачи. Эти алгоритмы принимают решение на основе текущего состояния проблемы и выбирают лучшее возможное решение в данный момент, не учитывая последствия этого выбора для будущих шагов решения.</p><blockquote><p>Жадные алгоритмы состоят из итераций, решение принимается на каждой итерации, стараясь найти локальное оптимальное решение.</p></blockquote><p>Представьте, что вам нужно посетить нескольких врачей в разных клиниках. Чтобы минимизировать время в пути, вы можете выбрать ближайшую клинику для первого визита, затем выбирать следующую клинику на основе её расположения относительно предыдущей, и так далее. Этот подход кажется логичным на каждом этапе, но он не учитывает общую длину маршрута и может привести к неоптимальному распределению времени.</p><h2 id="задача-об-интервалах" tabindex="-1">Задача об интервалах <a class="header-anchor" href="#задача-об-интервалах" aria-label="Permalink to &quot;Задача об интервалах&quot;">​</a></h2><p><strong>Задача об интервалах:</strong> дано множество отрезков разной длины, необходимо найти максимальную длину множества(кол-во интервалов) в котором отрезки не пересекаются.</p><ol><li>Отсортируйте отрезки по их конечным точкам.</li><li>Выберите первый отрезок (с наименьшей конечной точкой).</li><li>Проходите по списку отрезков и выбирайте каждый следующий отрезок, если он не пересекается с последним выбранным отрезком.</li></ol><p><img src="https://lh7-us.googleusercontent.com/docsz/AD_4nXe8Q8wMdwag2AziCXXWlQWRcol8-h_n_m6GcBD3Mj8-gPJgiAzL_LEtPjy5YWLP3ap5J3TZqrx6DXFJQc6c4Og1ORBSoY6qMu3VLz2Qq6GlEBZxrIAH1UVhbTjeQkgC3n9BznGPGmpiNvrpANy7KZ355dTJ?key=9gziK4gT-jwK64_BpOeehQ" alt=""></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> find_max_non_overlapping_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(intervals):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    start_points </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([interval[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interval </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intervals])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current_interval </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start_points:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_interval </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_interval[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current_interval </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (start, intervals[start_points.index(start)][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            max_count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_count</span></span></code></pre></div>`,10),l=[h];function p(k,e,r,E,d,o){return a(),i("div",null,l)}const y=s(t,[["render",p]]);export{c as __pageData,y as default};
