import{_ as a,c as i,o as l,a2 as t}from"./chunks/framework.C94oF1kp.js";const h=JSON.parse('{"title":"Динамическое программирование. Задача о возрастающей подпоследовательности наибольшей длины.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/040.md","filePath":"tasks/040.md"}'),e={name:"tasks/040.md"},o=t('<h1 id="динамическое-программирование-задача-о-возрастающеи-подпоследовательности-наибольшеи-длины" tabindex="-1">Динамическое программирование. Задача о возрастающей подпоследовательности наибольшей длины. <a class="header-anchor" href="#динамическое-программирование-задача-о-возрастающеи-подпоследовательности-наибольшеи-длины" aria-label="Permalink to &quot;Динамическое программирование. Задача о возрастающей подпоследовательности наибольшей длины.&quot;">​</a></h1><h2 id="условие" tabindex="-1">Условие <a class="header-anchor" href="#условие" aria-label="Permalink to &quot;Условие&quot;">​</a></h2><p><strong>Задача о возрастающей подпоследовательности наибольшей длины:</strong> Дана последовательность чисел, необходимо найти наибольшую по длине возрастающую подпоследовательность.</p><p>Для последовательности {1, 4, 2, 5, 3} решение будет таким:</p><ul><li>f5 = 1 + max(f1, f3)</li><li>f4 = 1 + max(f1, f2, f3)</li><li>f3 = 1 + max(f1)</li><li>f2 = 1 + max(f1)</li><li>f1 = 1. Возвращаемся назад</li><li>f2 = 1 + max(f1) = 2</li><li>f3 = 1 + max(f1) = 2</li><li>f4 = 1 + max(f1, f2, f3) = 3</li><li>f5 = 1 + max(f1, f3) = 3. Решение есть max(f1, f2, f3, f4, f5) = 3.</li></ul><p>Чтобы повторно не решать решённые подзадачи, введём массив c размером, хранящий значения вычисленных функций. Начальные значения его равны нулю — значению, которое не может быть верным решением любой из одзадач. Это позволит нам определить, решали ли мы эту подзадачу или нет. Если нет — запускаем решение для требуемого аргумента, и после получения результата сохраняем его.</p><h2 id="решение" tabindex="-1">Решение <a class="header-anchor" href="#решение" aria-label="Permalink to &quot;Решение&quot;">​</a></h2><p><strong>Алгоритм сложностью O(n^2):</strong></p><p>есть входной массив последовательности a[....], и массив dp[...], где будем хранить максимальное значение длины последовательности, так что dp[ i ] - это максимальная длина последовательности которая оканчивается на a[i].</p><p>Начальное значение dp[o] = 1.</p><p>Порядок действий для нахождение dp[i]:</p><ol><li>получаем значение из a[ i ]</li><li>циклом проходимся  по элементам начиная  с i до 0</li><li>если находим значение a[ j ] меньшее нашего, получаем длину его подпоследовательности как dp[ j ]</li><li>в dp[ i ] заносим максимальное из найденных значений в п.3 с “+ 1”</li></ol><p><strong>Алгоритм сложность O(n log n):</strong></p><ol><li>создадим дополнительный массив dp длины N (длина входного массива a): нулевой элемент ставим  -INF, остальные INF ( dp = [-inf, inf, inf, …].)</li><li>получаем dp[ i ], i - длина последовательности,  dp[ i ] - значение последнего элемента этой последовательности</li><li>благодаря такой структуре все значения в dp будут хранится в отсортированном порядке, ведь чем больше значение, тем больше элементов могут поместиться перед ним 4)  проходимся по a[] и  бинарным поиском находим такое k, что (dp[k-1] &lt; x &amp;&amp; dp[k] &gt;= x) и присваиваем dp[k] значение x</li><li>ответ, это наибольший индекс массива dp отличный от INF</li></ol>',14),p=[o];function f(r,n,s,d,_,c){return l(),i("div",null,p)}const x=a(e,[["render",f]]);export{h as __pageData,x as default};
