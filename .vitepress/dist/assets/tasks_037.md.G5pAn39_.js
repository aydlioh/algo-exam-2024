import{_ as t,c as a,o as e,a2 as o}from"./chunks/framework.C94oF1kp.js";const s="/assets/8.B0yHDMWm.png",m=JSON.parse('{"title":"Двоичные деревья. Алгоритм Хаффмана.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/037.md","filePath":"tasks/037.md"}'),l={name:"tasks/037.md"},r=o('<h1 id="двоичные-деревья-алгоритм-хаффмана" tabindex="-1">Двоичные деревья. Алгоритм Хаффмана. <a class="header-anchor" href="#двоичные-деревья-алгоритм-хаффмана" aria-label="Permalink to &quot;Двоичные деревья. Алгоритм Хаффмана.&quot;">​</a></h1><h2 id="задача" tabindex="-1">Задача <a class="header-anchor" href="#задача" aria-label="Permalink to &quot;Задача&quot;">​</a></h2><p><strong>Задача:</strong> найти минимальный префиксный код для множества.(префиксный означает что никакой символ не является префиксом другого символа при кодировании)</p><p>Пусть имеется текст, состоящий из множества 4 символов: AAAAAAAAAAAABBBBBBCCD</p><p>Его длина 21 символов. Текст можно закодировать следующим образом:</p><p>(A -&gt; 00),(B -&gt; 01),(C -&gt; 10),(D -&gt; 11)</p><p>Для простоты и наглядности разместим наш алфавит в виде двоичного дерева</p><p><img src="https://lh7-us.googleusercontent.com/docsz/AD_4nXcarul1LPHAemZNB_Y3x-fbnZy6ufOK_-y55z6zTW9ow04r3xEjGFT3bIyjmTfHZJ1vXwqJ4URKN1wx_lGkmf6lcSo70vMUsGkSJ0qlDG2khTsz6Glaz7Ki0EbH9rsyyJmcn4KGfuSwvyaGpRQkQrqpKq5Y?key=9gziK4gT-jwK64_BpOeehQ" alt=""></p><p><code>Для кодирования каждого символа понадобится 2 бита и длина кода составит 42 бит.</code></p><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Алгоритм Хаффмана</strong> -  алгоритм оптимального префиксного кодирования алфавита. Его идея состоит в подсчёта частоты вхождения каждого элемента во множестве. Чем чаще встречается элемент тем меньше он должен весить.</p><h2 id="алгоритм" tabindex="-1">Алгоритм <a class="header-anchor" href="#алгоритм" aria-label="Permalink to &quot;Алгоритм&quot;">​</a></h2><ol><li>помещаем в каждый узел частоту символа</li><li>располагаем узлы в порядке убывания</li><li>для 2 наименьших добавляем узел, который их соединяет</li><li>его значение cоотвествует сумме частот его детей</li><li>повторяем с п.3</li></ol><p>Вернемся к примеру:  AAAAAAAAAAAABBBBBBCCD Вычисляем частоты вхождений: F(a) = 12; F(b) = 6; F(c) = 2; F(d) = 1;</p><p>Ход решения:</p><ol><li>выбираем 2 узла с наименьшей частотой(С и D), помещаем их на 1 уровень, соединяем с родителем CD=3</li><li>Повторяем п.1, но уже для множества A=12, B=6, CD=3</li></ol><p><img src="'+s+'" alt=""></p><p>Ответом для данного набора является</p><p><code>A =&gt; 0; B =&gt; 10; C =&gt; 110; D =&gt; 111</code></p><p><strong>Общая длина составит 33 бита что &lt; 42.</strong></p>',20),i=[r];function p(n,c,_,A,d,h){return e(),a("div",null,i)}const B=t(l,[["render",p]]);export{m as __pageData,B as default};
