import{_ as a,c as t,o as s,a2 as o}from"./chunks/framework.C94oF1kp.js";const e="/assets/19.BOEh-F3R.png",r="/assets/20.C_6yZYcr.png",n="/assets/21.BsjJ16lg.png",i="/assets/22.BwZuv-5w.png",c="/assets/23.McTgpGFc.png",l="/assets/24.CvCWOD22.png",q=JSON.parse('{"title":"Алгоритм Флойда-Уоршалла.","description":"","frontmatter":{},"headers":[],"relativePath":"tasks/052.md","filePath":"tasks/052.md"}'),p={name:"tasks/052.md"},_=o('<h1 id="алгоритм-флоида-уоршалла" tabindex="-1">Алгоритм Флойда-Уоршалла. <a class="header-anchor" href="#алгоритм-флоида-уоршалла" aria-label="Permalink to &quot;Алгоритм Флойда-Уоршалла.&quot;">​</a></h1><h2 id="определение" tabindex="-1">Определение <a class="header-anchor" href="#определение" aria-label="Permalink to &quot;Определение&quot;">​</a></h2><p><strong>Алгоритм Флойда-Уоршалла</strong> используется для нахождения кратчайших путей между всеми парами вершин во взвешенном ориентированном графе, даже если в нем присутствуют ребра с отрицательными весами.</p><h2 id="алгоритм" tabindex="-1">Алгоритм <a class="header-anchor" href="#алгоритм" aria-label="Permalink to &quot;Алгоритм&quot;">​</a></h2><ol><li><strong>Инициализация:</strong> Создайте матрицу смежности для графа, где каждый элемент a[i][j] представляет собой вес ребра между вершинами i и j. Если между вершинами нет ребра, то a[i][j] устанавливается как бесконечность. Затем установите диагональные элементы матрицы равными 0.</li><li><strong>Обновление расстояний:</strong> Для каждой пары вершин (i, j) проверьте, проходит ли путь через вершину k (от 1 до n, где n - количество вершин) быстрее, чем текущий известный путь между вершинами i и j. Если да, обновите значение a[i][j] на минимальное из (a[i][j], a[i][k] + a[k][j]).</li><li><strong>Повторение:</strong> Шаг 2 повторяется для каждой пары вершин (i, j) с использованием каждой вершины k.</li><li><strong>Завершение:</strong> По завершении работы алгоритма, матрица смежности будет содержать кратчайшие расстояния между всеми парами вершин.</li></ol><p><code>Алгоритм Флойда-Уоршалла работает для всех типов графов</code>, включая графы с отрицательными ребрами, и может быть использован для поиска кратчайших путей между всеми парами вершин в графе.</p><p><strong>Сложность O(n^3), n -  число вершин (рассматривается каждая пара это n^2, + пытаемся провести эту пару через каждую из вершин это n, и того n^3)</strong></p><h2 id="код" tabindex="-1">Код <a class="header-anchor" href="#код" aria-label="Permalink to &quot;Код&quot;">​</a></h2><p><img src="'+e+'" alt=""></p><h2 id="пример" tabindex="-1">Пример <a class="header-anchor" href="#пример" aria-label="Permalink to &quot;Пример&quot;">​</a></h2><p><img src="'+r+'" alt=""></p><p><img src="'+n+'" alt=""></p><p><img src="'+i+'" alt=""></p><p><img src="'+c+'" alt=""></p><p>Бла Бла Бла...</p><p><img src="'+l+'" alt=""></p>',16),h=[_];function d(g,m,u,k,f,b){return s(),t("div",null,h)}const P=a(p,[["render",d]]);export{q as __pageData,P as default};
